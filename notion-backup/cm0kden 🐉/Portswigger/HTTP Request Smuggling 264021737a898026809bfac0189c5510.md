# HTTP Request Smuggling

Created: September 4, 2025 1:52 PM

## What happens in an HTTP request smuggling attack?

Today's web applications frequently employ chains of HTTP 
servers between users and the ultimate application logic. Users send 
requests a front-end server (sometimes called a load balancer or 
reverse proxy) and this server forwards requests to one or more back-end

This type of architecture is increasingly common, and in 
some cases unavoidable, in modern cloud-based applications.

When the front-end server forwards HTTP requests to a 
back-end server, it typically sends several requests over the same 
back-end connection, because this is much more efficient and 
performant. The protocol is very simple; HTTP requests are sent one 
after another, the receiving server has to determine where one request ends
 and the next one begins:

![Forwarding HTTP requests to a back-end server](https://portswigger.net/web-security/images/forwarding-http-requests-to-back-end-server.svg)

In this situation, it is crucial that the front-end and 
back-end systems agree about the boundaries between requests. Otherwise,
 an attacker might be able to send an ambiguous request that 
gets interpreted differently by the front-end and back-end systems:

IMPORTANT NOTE: This shows the case where the frontend server is keeping a single TCP connection with backend for upcoming requests!! If each coming request is served with a separate TCP connection, then this technique is non usable, but others like request tunneling might work.

![Smuggling an HTTP request to a back-end server](https://portswigger.net/web-security/images/smuggling-http-request-to-back-end-server.svg)

Here, the attacker causes part of their front-end request to
 be interpreted by the back-end server as the start of the next request.
 It effectively prepended to the next request, and so can 
interfere with the way the application processes that request. This is a
 smuggling attack, and it can have devastating results.

## How do HTTP request smuggling vulnerabilities arise?

Most HTTP request smuggling vulnerabilities arise because 
the HTTP/1 specification provides two different ways to specify where a 
request ends: the `Content-Length` header and the `Transfer-Encoding` header.

The `Content-Length` header is straightforward: it specifies the length of the message body in bytes. For example:

```
POST /search HTTP/1.1
Host: normal-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 11

q=smuggling
```

The `Transfer-Encoding` header can be used to 
specify that the message body uses chunked encoding. This means that the message body contains one or more chunks of 
data. Each chunk consists of the chunk size in bytes (expressed in hexadecimal), followed by a newline, followed by the chunk contents. The message is terminated with a chunk of size zero. For 
example:

```
POST /search HTTP/1.1
Host: normal-website.com
Content-Type: application/x-www-form-urlencoded
Transfer-Encoding: chunked

b
q=smuggling
0

```

### Note

Many security testers are unaware that chunked encoding can be used in HTTP requests, for two reasons:

- Burp Suite automatically unpacks chunked encoding to make messages easier to view and edit.
- Browsers do not normally use chunked encoding in requests, and it is normally seen only in server responses.

As the HTTP/1 specification provides two different methods 
for specifying the length of HTTP messages, it is possible for a single message to use both methods at once, such that they conflict with each other. The specification attempts to prevent this problem by stating that if both the `Content-Length` and `Transfer-Encoding` headers are present, then the `Content-Length` header should be ignored. This might be sufficient to avoid ambiguity when only a single server is in play, but not when two or more servers are chained together. In this situation, problems can arise for two reasons:

- Some servers do not support the `Transfer-Encoding` header in requests.
- Some servers that do support the `Transfer-Encoding` header can be induced not to process it if the header is obfuscated in some way.

If the front-end and back-end servers behave differently in relation to the (possibly obfuscated) `Transfer-Encoding`header, then they might disagree about the boundaries 
between successive requests, leading to request smuggling 
vulnerabilities.

### Note

Websites that use HTTP/2 end-to-end are inherently 
immune to request smuggling attacks. As the HTTP/2 specification 
introduces a single, robust mechanism for specifying the length of a 
request, there is no way for an attacker to introduce the required 
ambiguity.

However, many websites have an HTTP/2-speaking front-end
 server, but deploy this in front of back-end infrastructure that only 
supports HTTP/1. This means that the front-end effectively has to 
translate the requests it receives into HTTP/1. This process is known as
 HTTP downgrading. For more information, see [Advanced request smuggling](https://portswigger.net/web-security/request-smuggling/advanced).

## How to perform an HTTP request smuggling attack

Classic request smuggling attacks involve placing both the `Content-Length` header and the `Transfer-Encoding`header into a single HTTP/1 request and manipulating these 
so that the front-end and back-end servers process the request 
differently. The exact way in which this is done depends on the behavior of 
the two servers:

- CL.TE: the front-end server uses the `Content-Length` header and the back-end server uses the `Transfer-Encoding` header.
- TE.CL: the front-end server uses the `Transfer-Encoding` header and the back-end server uses the `Content-Length` header.
- TE.TE: the front-end and back-end servers both support the `Transfer-Encoding` header, but one of the servers can be induced not to process it by obfuscating the header in some way.

### Note

These techniques are only possible using HTTP/1 requests. Browsers and other clients, including Burp, use HTTP/2 by default to communicate with servers that explicitly advertise support 
for it during the TLS handshake.

As a result, when testing sites with HTTP/2 support, you need to manually switch protocols in Burp Repeater. You can do this from the **Request attributes** section of the **Inspector** panel.

### General Detection methodology

![image.png](HTTP%20Request%20Smuggling/image.png)

```xml
Content-Length: 6
Transfer-Encoding: chunked

0

X
```

```xml
Content-Length: 6
Transfer-Encoding: chunked

3
abc
X
```

[Finding HTTP request smuggling vulnerabilities | Web Security Academy](https://portswigger.net/web-security/request-smuggling/finding)

One more good technique to detect HTTP Request smuggling vulnerability is a Differential Response Method. To do that, we’re smuggling a complete, intentionally malformed request (usually trying to access nonexistent path so that it always triggers 404), and send attack request twice. If you do this and receive 2 different responses, that means that the request has been smuggled and the vulnerability exists.

![image.png](HTTP%20Request%20Smuggling/image%201.png)

### CL.TE vulnerabilities

Here, the front-end server uses the `Content-Length` header and the back-end server uses the `Transfer-Encoding` header. We can perform a simple HTTP request smuggling attack as follows:

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 13
Transfer-Encoding: chunked

0

SMUGGLED
```

The front-end server processes the `Content-Length` header and determines that the request body is 13 bytes long, up to the end of `SMUGGLED`. This request is forwarded on to the back-end server.

The back-end server processes the `Transfer-Encoding`
 header, and so treats the message body as using chunked encoding. It processes the first chunk, which is stated to be zero length, and so is treated as terminating the request. 
The following bytes, `SMUGGLED`, are left unprocessed, and the back-end server will treat these as being the start of the next request in the sequence.

[Detecting CL.TE methodology](HTTP%20Request%20Smuggling/Detecting%20CL%20TE%20methodology%20264021737a898084af55cd424837fc23.md)

[CL.TE Request Smuggling](HTTP%20Request%20Smuggling/CL%20TE%20Request%20Smuggling%20264021737a8980b1b9e1d7e61be9e677.md)

### [TE.CL](http://TE.CL) vulnerabilities

Remember: CHUNKS ARE ONLY USED TO CARRY REQUEST BODY, NOT THE REQUEST ITSELF

[Detecting [TE.CL](http://TE.CL) methodology](HTTP%20Request%20Smuggling/Detecting%20TE%20CL%20methodology%20265021737a8980adb419d7c33d470de2.md)

[[TE.CL](http://TE.CL) Request Smuggling](HTTP%20Request%20Smuggling/TE%20CL%20Request%20Smuggling%20265021737a89806084fce596dfd701a8.md)

### TE.TE vulnerabilities

Here, the front-end and back-end servers both support the `Transfer-Encoding` header, but one of the servers can be induced not to process it by obfuscating the header in some way.

There are potentially endless ways to obfuscate the `Transfer-Encoding` header. For example:

![image.png](HTTP%20Request%20Smuggling/image%202.png)

Each of these techniques involves a subtle departure from 
the HTTP specification. Real-world code that implements a protocol specification rarely adheres to it with absolute precision, and it is common for different implementations to tolerate different variations from the specification. To uncover a TE.TE vulnerability, it is necessary to find some variation of the `Transfer-Encoding` header such that only one of the front-end or back-end servers processes it, while the other server ignores it.

Depending on whether it is the front-end or the back-end server that can be induced not to process the obfuscated `Transfer-Encoding` header, the remainder of the attack will take the same form as for the CL.TE or [TE.CL](http://TE.CL) vulnerabilities already described.

[Detecting TE.TE vulnerability](HTTP%20Request%20Smuggling/Detecting%20TE%20TE%20vulnerability%2026a021737a8980b4bb5ac7135360477a.md)

[TE.TE Request smuggling (true TE.CL)](HTTP%20Request%20Smuggling/TE%20TE%20Request%20smuggling%20(true%20TE%20CL)%2026a021737a8980a29f09e3493e15572f.md)

### H2 Request smuggling

Check out corresponding labs

### HTTP Request tunneling

Many of the request smuggling attacks we've covered are only possible because the same connection between the front-end and back-end handles multiple requests. Although some servers will reuse the connection for any requests, others have stricter policies.

[HTTP request tunnelling | Web Security Academy](https://portswigger.net/web-security/request-smuggling/advanced/request-tunnelling)

It’s also important to understand how CRLF helps in request splitting:

https://medium.com/@instatunnel/crlf-injection-injecting-new-lines-hijacking-responses-f3c8ceaae377

### CL.0 Request smuggling

Request smuggling vulnerabilities are the result of 
discrepancies in how chained systems determine where each request starts
 and ends. This is typically due to [inconsistent header parsing](https://portswigger.net/web-security/request-smuggling#how-do-http-request-smuggling-vulnerabilities-arise), leading to one server using a request's `Content-Length`and the other treating the message as chunked. However, it's possible 
to perform many of the same attacks without relying on either of these 
issues.

In some instances, servers can be persuaded to ignore the `Content-Length` header, meaning they assume that each request finishes at the end of the headers. This is effectively the same as treating the `Content-Length` as `0`.

If the back-end server exhibits this behavior, but the front-end still uses the `Content-Length`
 header to determine where the request ends, you can potentially exploit
 this discrepancy for HTTP request smuggling. We've decided to call this
 a "CL.0" vulnerability.

---

### Exploiting

[Frontend security controls bypass by CL.TE vulnerability](HTTP%20Request%20Smuggling/Frontend%20security%20controls%20bypass%20by%20CL%20TE%20vulnera%2026a021737a89803e8a19dd8f211b8308.md)

[Frontend security controls bypass by [TE.CL](http://TE.CL) vulnerability](HTTP%20Request%20Smuggling/Frontend%20security%20controls%20bypass%20by%20TE%20CL%20vulnera%2026a021737a8980dc9bd8ca206d87cef5.md)

[Request rewriting disclosure by request smuggling](HTTP%20Request%20Smuggling/Request%20rewriting%20disclosure%20by%20request%20smuggling%2026a021737a89809ea2e5fe737ff89831.md)

[Stealing other users requests using request smuggling](HTTP%20Request%20Smuggling/Stealing%20other%20users%20requests%20using%20request%20smuggl%2026a021737a898093a7ecf807d01ecaad.md)

[XSS+ via Request smuggling](HTTP%20Request%20Smuggling/XSS+%20via%20Request%20smuggling%2026a021737a8980f8b157ea02c9ff9422.md)

[[H2.CL](http://H2.CL) request smuggling](HTTP%20Request%20Smuggling/H2%20CL%20request%20smuggling%2026b021737a8980e4b77fd0ed2e34e33b.md)

[H2.TE response queue poisoning via request smuggling](HTTP%20Request%20Smuggling/H2%20TE%20response%20queue%20poisoning%20via%20request%20smuggli%2026b021737a8980fd8418d9621c04ede0.md)

[HTTP2 request smuggling via CRLF injection](HTTP%20Request%20Smuggling/HTTP2%20request%20smuggling%20via%20CRLF%20injection%2026b021737a8980ccba07ded308075284.md)

[HTTP2 Request splitting using CRLF](HTTP%20Request%20Smuggling/HTTP2%20Request%20splitting%20using%20CRLF%2026b021737a89807ba03de7c2f0660f84.md)

[CL.0 Request smuggling](HTTP%20Request%20Smuggling/CL%200%20Request%20smuggling%2026c021737a8980978170ef2a878ae6fb.md)

[EXPERT: **0.CL request smuggling**](HTTP%20Request%20Smuggling/EXPERT%200%20CL%20request%20smuggling%202bc021737a898056be71f60ca42b6cf9.md)

[EXPERT: **Exploiting HTTP request smuggling to perform web cache poisoning**](HTTP%20Request%20Smuggling/EXPERT%20Exploiting%20HTTP%20request%20smuggling%20to%20perfor%202bc021737a89808b9db2f3be94f4f9d2.md)

[EXPERT: **Exploiting HTTP request smuggling to perform web cache deception**](HTTP%20Request%20Smuggling/EXPERT%20Exploiting%20HTTP%20request%20smuggling%20to%20perfor%202bf021737a8980ee96f5ee47c2b885c1.md)

[EXPERT: **Bypassing access controls via HTTP/2 request tunnelling**](HTTP%20Request%20Smuggling/EXPERT%20Bypassing%20access%20controls%20via%20HTTP%202%20reques%202bc021737a89803d8e1ed8db976d533c.md)

[EXPERT: **Web cache poisoning via HTTP/2 request tunnelling**](HTTP%20Request%20Smuggling/EXPERT%20Web%20cache%20poisoning%20via%20HTTP%202%20request%20tunn%202bc021737a898036ba58efbd11a7a59c.md)

[EXPERT: Client-side desync](HTTP%20Request%20Smuggling/EXPERT%20Client-side%20desync%202bd021737a8980af9729f9d9bab0895b.md)

[EXPERT: **Server-side pause-based request smuggling**](HTTP%20Request%20Smuggling/EXPERT%20Server-side%20pause-based%20request%20smuggling%202bd021737a89808ebfd9e86d9d2abdb6.md)

---

### Preventing

![image.png](HTTP%20Request%20Smuggling/image%203.png)

Cool article: https://www.yeswehack.com/learn-bug-bounty/http-request-smuggling-guide-vulnerabilities