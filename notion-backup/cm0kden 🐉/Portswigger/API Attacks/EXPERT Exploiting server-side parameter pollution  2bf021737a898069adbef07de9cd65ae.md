# EXPERT: Exploiting server-side parameter pollution in a REST URL

https://siunam321.github.io/ctf/portswigger-labs/api-testing/api-5/

Admin pass reset

![Снимок экрана 2025-12-04 в 10.03.34.png](EXPERT%20Exploiting%20server-side%20parameter%20pollution%20/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA_%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0_2025-12-04_%D0%B2_10.03.34.png)

Adding # resulted to routing error, suggesting that it was inserted directly into the URL

![Снимок экрана 2025-12-04 в 10.03.53.png](EXPERT%20Exploiting%20server-side%20parameter%20pollution%20/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA_%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0_2025-12-04_%D0%B2_10.03.53.png)

Same for `?`

![Снимок экрана 2025-12-04 в 10.05.41.png](EXPERT%20Exploiting%20server-side%20parameter%20pollution%20/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA_%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0_2025-12-04_%D0%B2_10.05.41.png)

What if we try to access API definition using path traversal:

![Снимок экрана 2025-12-04 в 10.11.45.png](EXPERT%20Exploiting%20server-side%20parameter%20pollution%20/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA_%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0_2025-12-04_%D0%B2_10.11.45.png)

Following the spec:

![Снимок экрана 2025-12-04 в 10.13.18.png](EXPERT%20Exploiting%20server-side%20parameter%20pollution%20/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA_%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0_2025-12-04_%D0%B2_10.13.18.png)

There’s also a script being loaded in forgot password page:

![Снимок экрана 2025-12-04 в 10.14.41.png](EXPERT%20Exploiting%20server-side%20parameter%20pollution%20/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA_%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0_2025-12-04_%D0%B2_10.14.41.png)

Let’s try to retrieve pass reset token:

![Снимок экрана 2025-12-04 в 10.16.00.png](EXPERT%20Exploiting%20server-side%20parameter%20pollution%20/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA_%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0_2025-12-04_%D0%B2_10.16.00.png)

![Снимок экрана 2025-12-04 в 10.16.41.png](EXPERT%20Exploiting%20server-side%20parameter%20pollution%20/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA_%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0_2025-12-04_%D0%B2_10.16.41.png)

Now we can log in as an administrator and pwn the lab

![Снимок экрана 2025-12-04 в 10.17.43.png](EXPERT%20Exploiting%20server-side%20parameter%20pollution%20/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA_%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0_2025-12-04_%D0%B2_10.17.43.png)

---

Excellent question! This is a fascinating vulnerability that combines **server-side parameter pollution** with **REST API path traversal**. Let me break down the core concepts:

## **What Happened Here?**

The application has **two layers**:

1. **Front-end** (`/forgot-password`) - Accepts username, processes it
2. **Back-end REST API** (`/api/users/{username}/email`) - Actually fetches user data

The vulnerability: **The front-end blindly forwards user input into the API URL path!**

## **Understanding the API Hierarchy**

```
Front-end: POST /forgot-password?username=value
    ↓ (Internally)
Back-end: GET /api/users/{username}/email
    ↓ (Returns)
User's email for password reset

```

The key insight: The `username` parameter from the front-end gets **directly inserted** into the API path:

```python
# Pseudo-code of the vulnerable application
def forgot_password(username):
    # Vulnerable! Direct string concatenation
    api_url = f"/api/users/{username}/email"
    response = internal_api.get(api_url)
    # Process response...

```

## **How Path Traversal Works**

When you submit `username=foobar/../administrator`:

```
Front-end receives: username="foobar/../administrator"
Front-end constructs: /api/users/foobar/../administrator/email
API normalizes path: /api/users/administrator/email  ← Traversal complete!

```

The `../` moves **up one directory** in the path hierarchy:

- `/api/users/foobar/` → go into `foobar` directory
- `../` → go back up to `/api/users/`
- `administrator/email` → go into `administrator/email`

## **Why the `#` (Hash/Fragment) Matters**

The writeup shows `username=foobar%23` (`#` URL-encoded) initially.

The `#` marks the **beginning of a URL fragment** (client-side only). When the front-end constructs:

```
/api/users/foobar#/email

```

Everything after `#` is ignored by the server! So the API tries to access:

```
GET /api/users/foobar

```

And returns "Invalid route" because it expects `/api/users/{username}/email`.

This reveals the **internal API structure** through error messages.

## **Real-World Detection Techniques**

### **1. Look for RESTful URL Patterns**

```
/api/users/{id}
/api/products/{category}/{id}
/customer/{name}/profile

```

Any endpoint with **parameters in the path** (not query string) is suspect.

### **2. Test with Special Characters**

Try these in path parameters:

- `../` - Path traversal
- `#` - URL fragment separator
- `?` - Query string separator
- `;` - Parameter separator
- `/` - Additional path segments
- `\\` - Alternative path separator (Windows)
- `%00` - Null byte (old systems)

### **3. Analyze Error Messages**

Submit: `username=test#`
If you get: "Invalid route: /api/users/test"
→ **Bingo!** You've discovered internal API structure.

Submit: `username=test/../admin`
If password reset goes to admin → **Path traversal confirmed!**

### **4. Fuzz API Documentation Endpoints**

Common locations:

- `/openapi.json` or `/openapi.yaml`
- `/swagger.json` or `/swagger.yaml`
- `/api-docs` or `/api/docs`
- `/swagger-ui.html` or `/swagger/index.html`
- `/redoc` or `/redocly.html`

### **5. Check for Information Disclosure**

Try traversing to:

- `/etc/passwd` (Unix)
- `/windows/win.ini` (Windows)
- Application config files
- API documentation
- Source code

## **Why This Is Dangerous**

1. **Privilege Escalation**: Reset admin password as shown
2. **Information Disclosure**: Access any user's data
3. **API Discovery**: Map internal API structure
4. **Potential RCE**: If API allows file operations

## **Defensive Measures**

For developers:

```python
# BAD - Direct concatenation
api_url = f"/api/users/{username}/email"

# GOOD - Validate and sanitize
def safe_username(username):
    # Block path traversal sequences
    if any(seq in username for seq in ['..', '/', '\\\\', '%00']):
        raise ValidationError("Invalid username")
    # Use allowlist for valid characters
    if not re.match(r'^[a-zA-Z0-9_\\-]+$', username):
        raise ValidationError("Invalid username format")
    return username

# Use parameterized API calls
api.get_user_email(username=safe_username(input_username))

```

## **Spotting These in Real Life**

### **Clue 1**: URLs with "RESTful" patterns

```
GET /api/v1/users/carlos/profile
POST /api/products/laptops/12345/review

```

### **Clue 2**: Error messages revealing internal paths

```
Error: Route /api/internal/users/foo not found

```

### **Clue 3**: Same parameter works in different contexts

```
GET /user?name=carlos  # Works
GET /api/user/carlos   # Also works (same data)

```

### **Clue 4**: Inconsistent validation

- Front-end validates `username` as alphanumeric
- But API accepts `username=../admin`
- Different validation layers = potential bypass

## **Exercise to Try**

Next time you test an app:

1. Find any endpoint with path parameters
2. Try `{parameter}/../something`
3. Try `{parameter}#`
4. Look for API docs
5. Chain vulnerabilities as shown

This vulnerability is subtle but powerful because it abuses **legitimate API patterns** that developers often implement without considering security implications of path construction.