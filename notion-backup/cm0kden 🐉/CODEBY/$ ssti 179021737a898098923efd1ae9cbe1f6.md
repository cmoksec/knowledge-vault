# $ ssti

Created: January 12, 2025 2:39 PM
Tags: refreshers

SSTI - это атака, в которой злоумышленник может использовать синтаксис шаблонизатора для внедрения вредоносного пейлоада в шаблон, который затем выполняется на стороне сервера.

Работу с SSTI нужно организовывать согласно следующему плану:

1. Обнаружение (Detect)
2. Идентификация (Identify)
3. Атака (Exploit)

## Обнаружение (Detect)

Прежде всего, нужно понимать, что SSTI - это атака на шаблонизатор, т.е. на движок динамически генерируемых страниц. При первичном сборе информации нужно обратить внимание на те сектора приложения, которые динамически заполняются содержимым при относительно неизменной форме. Эти элементы с большой вероятностью проходят через шаблонизатор. Как пример, в лаборатории была машина, которая на определенном URL генерировала простые HTML страницы, помещая в них последнюю часть пути (new/abc123 → в сгенерированной странице был текст abc123, и так для любого пути).

![image.png]($%20ssti/image.png)

При обнаружении такого элемента, нужно проверять наличие уязвимости с помощью типовых пейлоадов, допустим перебором Intruder и словарем из PayloadsAllTheThings. Как правило, это пейлоады типа {{7*7}}. Если в результате мы обнаружим, что выражение отрабатывает и мы получаем 49 в результате, значит перед нами SSTI уязвимость.

Это уязвимость в виде freetext, также пользовательский ввод может вставляться внутрь шаблона как переменная, это уже случай контекста кода. Подробнее в методичке.

## Идентификация (Identify)

После обнаружения уязвимости, нужно более точно определить природу шаблонизатора, так как их существует большое множество. Как правило, это делается с помощью специфического синтаксиса, который свойсвенен определенному шаблонизатору. Таблица для простой идентификации представлена ниже.

![image.png]($%20ssti/image%201.png)

## Атака (Exploit)

### Чтение

Важный шаг!!! После определения конкретного шаблона, **нужно** открыть документацию и почитать об особенностях его работы. Так можно **сильно** упростить себе задачу.

### Исследование окружения

Если в найденной версии шаблонизатора нет уже задокументированных уязвимостей, то следующим шагом будет исследование окружения, чтобы понять, к чему именно нам нужно получить доступ. Так можно найти объекты по умолчанию (подставляя их имена в конструкцию {{object_name}} или ${object_name} в зависимости от шаблонизатора). Так, например, в сложном задании лаборатории по шаблонизатору Jinja2 были доступны переменные g, request, get_flashed_messages, и с помощью последней переменной и удалось решить задание.

### Атака

Завершающий этап непосредственной эксплуатации. Мы исследуем доступные нам инструменты и максимально их развиваем. Здесь все зависит от степени защищенности приложения, это может быть RCE перетекающий в LFI и эскалацию привелегий, чтение рантайм конфигурации приложения, либо множество других исходов. Конкретные техники эксплуатации нужно смотреть для определенных шаблонизаторов, сред, и языков программирования.

### GET FLASK APP CONFIG

```bash
{{get_flashed_messages.__globals__.current_app.__dict__}}
```

---

[6.4. SSTI.pdf]($%20ssti/6.4._SSTI.pdf)

[6.4.1 Cheat sheet SSTI.pdf]($%20ssti/6.4.1_Cheat_sheet_SSTI.pdf)

Суперская статья по эксплуатации Jinja2 - https://www.onsecurity.io/blog/server-side-template-injection-with-jinja2/

[Доклад с BlackHat по SSTI](https://www.blackhat.com/docs/us-15/materials/us-15-Kettle-Server-Side-Template-Injection-RCE-For-The-Modern-Web-App-wp.pdf)

[Шпаргалка по SSTI](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection)

[notes.txt]($%20ssti/notes.txt)