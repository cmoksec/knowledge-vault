# Next Path

![Снимок экрана 2025-12-23 в 09.57.07.png](Next%20Path/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA_%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0_2025-12-23_%D0%B2_09.57.07.png)

```python
GET /api/team?id=123%0a&id=..//..//..//..//..//..//..//..//..//..//..//..//..//..//..//..//..//..//..//..//..//..//..//..//..//..//..//..//..//..//..//..//..//etc/passwd
```

```python
import path from 'path';
import fs from 'fs';

const ID_REGEX = /^[0-9]+$/m;

export default function handler({ query }, res) {
  if (!query.id) {
    res.status(400).end("Missing id parameter");
    return;
  }

  // Check format
  if (!ID_REGEX.test(query.id)) {
    console.error("Invalid format:", query.id);
    res.status(400).end("Invalid format");
    return;
  }
  // Prevent directory traversal
  if (query.id.includes("/") || query.id.includes("..")) {
    console.error("DIRECTORY TRAVERSAL DETECTED:", query.id);
    res.status(400).end("DIRECTORY TRAVERSAL DETECTED?!? This incident will be reported.");
    return;
  }

  try {
    const filepath = path.join("team", query.id + ".png");
    const content = fs.readFileSync(filepath.slice(0, 100));

    res.setHeader("Content-Type", "image/png");
    res.status(200).end(content);
  } catch (e) {
    console.error("Not Found", e.toString());
    res.status(404).end(e.toString());
  }
}

```

---

WRITEUP

Конечно. Это было одно из самых интересных и многослойных заданий, и оно заслуживает детального разбора. Вот финальная, расширенная версия райтапа, объединяющая все наши находки в единое повествование.

---

### **Райтап: CTF NextPath — Путь через ловушки, проверки и стены контейнера**

### **Введение**

Задание "NextPath" представляло собой веб-приложение на Next.js, которое под маской простой корпоративной страницы скрывало сложнейшую цепочку уязвимостей. Для его решения требовалось не только последовательно обойти несколько уровней защиты в коде, но и распознать ключевую механику манипуляции путями, чтобы в конечном итоге совершить побег из изолированного Docker-контейнера. Этот райтап подробно описывает каждый шаг этого увлекательного расследования.

---

### **Часть 1: Первоначальная разведка и постановка гипотезы**

Как и в любом CTF, мы начали с анализа исходных файлов. Ключевым файлом оказался `package.json`, который сразу дал нам два мощных направления для атаки:

1. **Имя проекта:** `"name": "nextpath"`. Комбинация "next" (фреймворк Next.js) и "path" (путь) была слишком очевидной, чтобы быть совпадением. Это была прямая подсказка на уязвимость **Path Traversal** (обход каталога).
2. **Подозрительная зависимость:** `"fs": "^0.0.1-security"`. Модуль `fs` является встроенным в Node.js, и его никогда не устанавливают через npm. Это был огромный красный флаг, указывающий на то, что стандартные функции работы с файловой системой (`fs.readFileSync` и т.д.) были переопределены кастомной, специально созданной для этого задания, версией.

Далее, анализ фронтенда в файле `/app/pages/index.js` выявил конкретную точку входа для атаки:

```html
<img src="/api/team?id=1" alt="Team Member 1" />

```

Это показало нам, что существует API-эндпоинт `/api/team`, который принимает GET-параметр `id`. Наша первоначальная гипотеза была сформирована: **приложение использует параметр `id` для чтения файла с сервера, и в этой логике присутствует уязвимость Path Traversal.**

---

### **Часть 2: Глубокий анализ уязвимого кода**

Серверный код в `/app/pages/api/team.js` был сердцем этого задания. Он содержал логику обработки запроса и, что более важно, несколько уровней защиты, которые нам предстояло взломать.

**Уязвимый код:**

```jsx
import path from 'path';
import fs from 'fs'; // <-- Используется подмененный, кастомный модуль!

const ID_REGEX = /^[0-9]+$/m; // <--- Уязвимость №1: Неправильное использование Regex

export default function handler({ query }, res) {
  // ... (проверка на наличие id)

  // Защита №1: Проверка формата
  if (!ID_REGEX.test(query.id)) {
    res.status(400).end("Invalid format");
    return;
  }
  // Защита №2: Прямая проверка на подстроки
  if (query.id.includes("/") || query.id.includes("..")) { // <--- Уязвимость №2: Неустойчивость к типам данных
    res.status(400).end("DIRECTORY TRAVERSAL DETECTED?!?");
    return;
  }

  try {
    const filepath = path.join("team", query.id + ".png"); // <-- Всегда добавляется .png
    const content = fs.readFileSync(filepath.slice(0, 100)); // <--- Уязвимость №3: Обрезка пути

    res.setHeader("Content-Type", "image/png");
    res.status(200).end(content);
  } catch (e) {
    // ...
  }
}

```

**Анализ защитных механизмов:**

- **Защита №1 (Regex):** `const ID_REGEX = /^[0-9]+$/m;`
На первый взгляд, это надежная проверка, требующая, чтобы `id` состоял только из цифр. Однако фатальной уязвимостью здесь является **флаг `m` (multiline)**. В многострочном режиме `^` и `$` означают начало и конец *каждой строки* в тексте, а не всего текста целиком. Это открывало возможность для обхода.
- **Защита №2 (`includes`):** `if (query.id.includes("/") || query.id.includes(".."))`
Эта проверка выглядит абсолютно надежной, если `query.id` является строкой. Она напрямую запрещает символы, необходимые для Path Traversal. Однако она не учитывает, что `query.id` может быть другого типа, например, массивом.
- **Проблема №3 (`slice` и `.png`):** Строки `filepath.slice(0, 100)` и `query.id + ".png"` создавали главную головоломку. Сервер всегда добавлял `.png`, а затем обрезал путь до 100 символов.

---

### **Часть 3: Построение многоступенчатого эксплойта**

**Обход №1: Regex Bypass**
Мы обошли первую защиту, используя уязвимость флага `m`. Отправив `id=1%0A` (где `%0A` — это URL-код символа новой строки `\\n`), мы передавали на сервер строку `1\\n`. Метод `.test()` видел первую строку `1`, она соответствовала шаблону `^[0-9]+$`, и проверка успешно проходилась.

**Обход №2: HTTP Parameter Pollution (HPP)**
Для обхода второй, более строгой проверки, мы использовали технику **HTTP Parameter Pollution**. Отправив два параметра с одинаковым именем (`?id=...&id=...`), мы заставили фреймворк Next.js обработать `query.id` не как строку, а как **массив**.
Наш запрос принял вид: `?id=1%0A&id=...payload...`.
На сервере `query.id` стал `['1\\n', '...payload...']`. Это позволило обойти проверку `includes()`:

1. При проверке `ID_REGEX.test(query.id)`, массив преобразуется в строку `"1\\n,...payload..."`. Благодаря флагу `m`, regex все равно находит совпадение в первой строке `1` и пропускает запрос.
2. При проверке `query.id.includes('..')`, метод `.includes()` применяется к **массиву** и ищет *целый элемент*, равный `'..'`, а не подстроку. Так как в нашем массиве такого элемента нет, эта проверка также успешно проходится.

**Обход №3: Взлом `slice(0, 100)` — Превращение ловушки в оружие**
Сначала `slice(0, 100)` казался отвлекающим маневром. Однако ваши методичные тесты доказали, что это **ключевая уязвимость для контроля над путем к файлу.**

1. **Тест на подтверждение обрезки:**
    - **Запрос:** `/api/team?id=1%0A&id=...(очень длинная цепочка ../)...flag.txt`
    - **Ответ:** `Error: ENOENT ... open '.../flag'`
    - **Вывод:** Этот ответ доказал, что `slice(0, 100)` активно работает. Он отрезал не только `.png`, но и `.txt`, оставив только `flag`.
2. **Тест на полный контроль над путем:**
    - **Запрос:** `/api/team?id=1%0A&id=./...(цепочка ../ откалиброванной длины)...flag.txt`
    - **Ответ:** `Error: ENOENT ... open './.../flag.txt'`
    - **Вывод:** Это был триумф. Мы создали payload такой длины, что после `slice(0, 100)` остался **идеально чистый путь к `flag.txt`**. Суффикс `.png` был успешно удален! Ошибка `ENOENT` теперь означала лишь одно: файла `flag.txt` в текущем (изолированном) окружении не существует.

---

### **Часть 4: Финальный прыжок — Побег из контейнера**

Теперь, когда у нас был полный контроль над путем к файлу, оставалось лишь указать правильный путь. Ошибка `ENOENT` при попытке прочитать локальный флаг подтвердила, что мы находимся в **Docker-контейнере**. Целью стал побег на файловую систему хост-машины.

**Детальный разбор конструкции побега:**`../../.../proc/1/task/1/root/proc/19/root/flag.txt`

Этот путь — не случайный набор директорий, а целенаправленная навигация по виртуальной файловой системе `/proc` Linux для эскалации привилегий из контейнера на хост.

- `../../...`: Сначала мы поднимаемся до корня файловой системы **внутри контейнера**.
- `/proc/`: Мы входим в директорию `/proc`, которая (из-за небезопасной конфигурации) является `/proc` **хост-машины**, смонтированной внутрь контейнера.
- `/proc/1/task/1/root/`: Мы обращаемся к процессу с `PID=1` (главный процесс `init` хоста), заходим в его директорию `task/1` (он сам) и по символической ссылке `root` попадаем в **корневой каталог (`/`) хост-машины**.
- `/proc/19/root/`: Оказавшись в корне хоста, мы снова заходим в `/proc` (уже хостовый) и обращаемся к другому процессу, например, с `PID=19`. Зайдя в его `root`, мы снова подтверждаем, что находимся в корне хоста. Эта избыточность повышает надежность эксплойта.
- `/flag.txt`: Находясь в корневой файловой системе хоста, мы наконец можем прочитать флаг.

### **Финальный эксплойт и победа**

Финальный эксплойт — это синергия всех найденных уязвимостей. Мы взяли **путь для побега из контейнера** и **откалибровали его длину** так, чтобы после добавления префикса и обрезки с помощью `slice(0, 100)` у нас оставался чистый путь к флагу на хосте.

Удаление суффикса `.png` с помощью `slice(0, 100)` было **критически необходимым шагом**, который позволил эксплойту на побег из контейнера вообще сработать.

**Финальный рабочий эксплойт:**

```
/api/team?id=1%0A%0D&id=../../../../../../../../../../../../../../../../../proc/1/task/1/root/proc/1/root/proc/1/task/1/root/flag.txt

```

Этот payload идеально сочетал в себе:

1. **HPP и Regex Bypass** для обхода защит.
2. **Path Traversal** для навигации.
3. **Точную длину**, чтобы уязвимость `slice(0, 100)` отрезала `.png`.
4. **Путь для побега из контейнера** для доступа к файлу флага.

**Ответ сервера:**

```
HTTP/1.1 200 OK
content-type: image/png
...
HTB{tr4v3r51ng_p45t_411_th3_ch3ck5...t4sk_w3ll_d0ne!}

```

Этот флаг стал заслуженной наградой за решение одной из самых многослойных и интересных задач, требующей не только технических навыков, но и умения распознавать сложные механики и делать правильные выводы из ошибок.